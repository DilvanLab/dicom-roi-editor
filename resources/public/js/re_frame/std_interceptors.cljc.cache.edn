{:rename-macros {}, :renames {}, :use-macros {}, :excludes #{}, :name re-frame.std-interceptors, :imports nil, :requires {re-frame.interceptor re-frame.interceptor, re-frame.loggers re-frame.loggers, registrar re-frame.registrar, re-frame.registrar re-frame.registrar, re-frame.db re-frame.db, data clojure.data, clojure.data clojure.data}, :uses {console re-frame.loggers, assoc-coeffect re-frame.interceptor, app-db re-frame.db, get-effect re-frame.interceptor, ->interceptor re-frame.interceptor, get-coeffect re-frame.interceptor, assoc-effect re-frame.interceptor}, :defs {debug {:name re-frame.std-interceptors/debug, :file "resources/public/js/re_frame/std_interceptors.cljc", :line 15, :column 1, :end-line 15, :end-column 11, :meta {:file "/Users/dilvan/OneDrive/IdeaProjects/dicom-roi-editor/resources/public/js/re_frame/std_interceptors.cljc", :line 15, :column 6, :end-line 15, :end-column 11}, :doc "An interceptor which logs data about the handling of an event.\n\n  Includes a `clojure.data/diff` of the db, before vs after, showing\n  the changes caused by the event handler.\n\n  You'd typically want this interceptor after (to the right of) any\n  path interceptor.\n\n  Warning:  calling clojure.data/diff on large, complex data structures\n  can be slow. So, you won't want this interceptor present in production\n  code. See the todomvc example to see how to exclude interceptors from\n  production code."}, trim-v {:name re-frame.std-interceptors/trim-v, :file "resources/public/js/re_frame/std_interceptors.cljc", :line 52, :column 1, :end-line 52, :end-column 12, :meta {:file "/Users/dilvan/OneDrive/IdeaProjects/dicom-roi-editor/resources/public/js/re_frame/std_interceptors.cljc", :line 52, :column 6, :end-line 52, :end-column 12}, :doc "An interceptor which removes the first element of the event vector,\n  allowing you to write more aesthetically pleasing db handlers. No\n  leading underscore on the event-v!\n  Your event handlers will look like this:\n\n      (defn my-handler\n        [db [x y z]]    ;; <-- instead of [_ x y z]\n        ....)"}, db-handler->interceptor {:protocol-inline nil, :meta {:file "/Users/dilvan/OneDrive/IdeaProjects/dicom-roi-editor/resources/public/js/re_frame/std_interceptors.cljc", :line 76, :column 7, :end-line 76, :end-column 30, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-db`.\n\n  These handlers take two arguments;  `db` and `event`, and they return `db`.\n\n  (fn [db event]\n     ....)\n\n  So, the interceptor wraps the given handler:\n     1. extracts two `:coeffects` keys: db and event\n     2. calls handler-fn\n     3. stores the db result back into context's `:effects`"}, :name re-frame.std-interceptors/db-handler->interceptor, :variadic false, :file "resources/public/js/re_frame/std_interceptors.cljc", :end-column 30, :method-params ([handler-fn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 76, :end-line 76, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-db`.\n\n  These handlers take two arguments;  `db` and `event`, and they return `db`.\n\n  (fn [db event]\n     ....)\n\n  So, the interceptor wraps the given handler:\n     1. extracts two `:coeffects` keys: db and event\n     2. calls handler-fn\n     3. stores the db result back into context's `:effects`"}, fx-handler->interceptor {:protocol-inline nil, :meta {:file "/Users/dilvan/OneDrive/IdeaProjects/dicom-roi-editor/resources/public/js/re_frame/std_interceptors.cljc", :line 98, :column 7, :end-line 98, :end-column 30, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-fx`.\n\n  These handlers take two arguments;  `coeffects` and `event`, and they return `effects`.\n\n  (fn [coeffects event]\n     {:db ...\n      :dispatch ...})\n\n   Wrap handler in an interceptor so it can be added to (the RHS) of a chain:\n     1. extracts `:coeffects`\n     2. call handler-fn giving coeffects\n     3. stores the result back into the `:effects`"}, :name re-frame.std-interceptors/fx-handler->interceptor, :variadic false, :file "resources/public/js/re_frame/std_interceptors.cljc", :end-column 30, :method-params ([handler-fn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 98, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-fx`.\n\n  These handlers take two arguments;  `coeffects` and `event`, and they return `effects`.\n\n  (fn [coeffects event]\n     {:db ...\n      :dispatch ...})\n\n   Wrap handler in an interceptor so it can be added to (the RHS) of a chain:\n     1. extracts `:coeffects`\n     2. call handler-fn giving coeffects\n     3. stores the result back into the `:effects`"}, ctx-handler->interceptor {:protocol-inline nil, :meta {:file "/Users/dilvan/OneDrive/IdeaProjects/dicom-roi-editor/resources/public/js/re_frame/std_interceptors.cljc", :line 121, :column 7, :end-line 121, :end-column 31, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-ctx`.\n  These advanced handlers take one argument: `context` and they return a modified `context`.\n  Example:\n     (fn [context]\n        (enqueue context [more interceptors]))"}, :name re-frame.std-interceptors/ctx-handler->interceptor, :variadic false, :file "resources/public/js/re_frame/std_interceptors.cljc", :end-column 31, :method-params ([handler-fn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 121, :end-line 121, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-ctx`.\n  These advanced handlers take one argument: `context` and they return a modified `context`.\n  Example:\n     (fn [context]\n        (enqueue context [more interceptors]))"}, path {:protocol-inline nil, :meta {:file "/Users/dilvan/OneDrive/IdeaProjects/dicom-roi-editor/resources/public/js/re_frame/std_interceptors.cljc", :line 136, :column 7, :end-line 136, :end-column 11, :arglists (quote ([& args])), :doc "An interceptor factory which supplies a sub-path of `:db` to the handler.\n  It's action is somewhat annologous to `update-in`. It grafts the return\n  value from the handler back into db.\n\n  Usage:\n    (path :some :path)\n    (path [:some :path])\n    (path [:some :path] :to :here)\n    (path [:some :path] [:to] :here)\n\n  Notes:\n    1. cater for `path` appearing more than once in an interceptor chain.\n    2. `:effect` may not contain `:db` effect. Which means no change to\n       `:db` should be made.\n  ", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :name re-frame.std-interceptors/path, :variadic true, :file "resources/public/js/re_frame/std_interceptors.cljc", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 136, :end-line 136, :max-fixed-arity 0, :fn-var true, :arglists ([& args]), :doc "An interceptor factory which supplies a sub-path of `:db` to the handler.\n  It's action is somewhat annologous to `update-in`. It grafts the return\n  value from the handler back into db.\n\n  Usage:\n    (path :some :path)\n    (path [:some :path])\n    (path [:some :path] :to :here)\n    (path [:some :path] [:to] :here)\n\n  Notes:\n    1. cater for `path` appearing more than once in an interceptor chain.\n    2. `:effect` may not contain `:db` effect. Which means no change to\n       `:db` should be made.\n  "}, enrich {:protocol-inline nil, :meta {:file "/Users/dilvan/OneDrive/IdeaProjects/dicom-roi-editor/resources/public/js/re_frame/std_interceptors.cljc", :line 180, :column 7, :end-line 180, :end-column 13, :arglists (quote ([f])), :doc "Interceptor factory which runs the given function `f` in the `after handler`\n  position.  `f` is called with two arguments: `db` and `v`, and is expected to\n  return a modified `db`.\n\n  Unlike the `after` inteceptor which is only about side effects, `enrich`\n  expects f to process and alter the given `db` coeffect in some useful way,\n  contributing to the derived data, flowing vibe.\n\n  Example Use:\n\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them in a warning\n  down the bottom of the panel.\n\n  Almost any action (edit text, add new todo, remove a todo) requires a\n  complete reassesment of duplication errors and warnings. Eg: that edit\n  update might have introduced a new duplicate or removed one. Same with a\n  todo removal.\n\n  And to perform this enrichment, a function has to inspect all the todos,\n  possibly set flags on each, and set some overall list of duplicates.\n  And this duplication check might just be one check among many.\n\n  `f` would need to be both adding and removing the duplicate warnings.\n  By applying `f` in middleware, we keep the handlers simple and yet we\n  ensure this important step is not missed."}, :name re-frame.std-interceptors/enrich, :variadic false, :file "resources/public/js/re_frame/std_interceptors.cljc", :end-column 13, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 180, :end-line 180, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Interceptor factory which runs the given function `f` in the `after handler`\n  position.  `f` is called with two arguments: `db` and `v`, and is expected to\n  return a modified `db`.\n\n  Unlike the `after` inteceptor which is only about side effects, `enrich`\n  expects f to process and alter the given `db` coeffect in some useful way,\n  contributing to the derived data, flowing vibe.\n\n  Example Use:\n\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them in a warning\n  down the bottom of the panel.\n\n  Almost any action (edit text, add new todo, remove a todo) requires a\n  complete reassesment of duplication errors and warnings. Eg: that edit\n  update might have introduced a new duplicate or removed one. Same with a\n  todo removal.\n\n  And to perform this enrichment, a function has to inspect all the todos,\n  possibly set flags on each, and set some overall list of duplicates.\n  And this duplication check might just be one check among many.\n\n  `f` would need to be both adding and removing the duplicate warnings.\n  By applying `f` in middleware, we keep the handlers simple and yet we\n  ensure this important step is not missed."}, after {:protocol-inline nil, :meta {:file "/Users/dilvan/OneDrive/IdeaProjects/dicom-roi-editor/resources/public/js/re_frame/std_interceptors.cljc", :line 219, :column 7, :end-line 219, :end-column 12, :arglists (quote ([f])), :doc "Interceptor factory which runs a given function `f` in the \"after\"\n  position, presumably for side effects.\n\n  `f` is called with two arguments: the `effects` value of `:db` and the event. It's return\n  value is ignored so `f` can only side-effect.\n\n  Example use:\n     - `f` runs schema validation (reporting any errors found)\n     - `f` writes some aspect of db to localstorage."}, :name re-frame.std-interceptors/after, :variadic false, :file "resources/public/js/re_frame/std_interceptors.cljc", :end-column 12, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 219, :end-line 219, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Interceptor factory which runs a given function `f` in the \"after\"\n  position, presumably for side effects.\n\n  `f` is called with two arguments: the `effects` value of `:db` and the event. It's return\n  value is ignored so `f` can only side-effect.\n\n  Example use:\n     - `f` runs schema validation (reporting any errors found)\n     - `f` writes some aspect of db to localstorage."}, on-changes {:protocol-inline nil, :meta {:file "/Users/dilvan/OneDrive/IdeaProjects/dicom-roi-editor/resources/public/js/re_frame/std_interceptors.cljc", :line 240, :column 8, :end-line 240, :end-column 18, :arglists (quote ([f out-path & in-paths])), :doc "Interceptor factory which acts a bit like `reaction`  (but it flows into `db`, rather than out)\n  It observes N paths in `db` and if any of them test not indentical? to their previous value\n  (as a result of a handler being run) then it runs `f` to compute a new value, which is\n  then assoced into the given `out-path` within `db`.\n\n  Usage:\n\n  (defn my-f\n    [a-val b-val]\n    ... some computation on a and b in here)\n\n  (on-changes my-f [:c]  [:a] [:b])\n\n  Put this Interceptor on the right handlers (ones which might change :a or :b).\n  It will:\n     - call `f` each time the value at path [:a] or [:b] changes\n     - call `f` with the values extracted from [:a] [:b]\n     - assoc the return value from `f` into the path  [:c]\n  ", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(f out-path in-paths)], :arglists ([f out-path & in-paths]), :arglists-meta (nil)}}, :name re-frame.std-interceptors/on-changes, :variadic true, :file "resources/public/js/re_frame/std_interceptors.cljc", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(f out-path in-paths)], :arglists ([f out-path & in-paths]), :arglists-meta (nil)}, :method-params [(f out-path in-paths)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 240, :end-line 240, :max-fixed-arity 2, :fn-var true, :arglists ([f out-path & in-paths]), :doc "Interceptor factory which acts a bit like `reaction`  (but it flows into `db`, rather than out)\n  It observes N paths in `db` and if any of them test not indentical? to their previous value\n  (as a result of a handler being run) then it runs `f` to compute a new value, which is\n  then assoced into the given `out-path` within `db`.\n\n  Usage:\n\n  (defn my-f\n    [a-val b-val]\n    ... some computation on a and b in here)\n\n  (on-changes my-f [:c]  [:a] [:b])\n\n  Put this Interceptor on the right handlers (ones which might change :a or :b).\n  It will:\n     - call `f` each time the value at path [:a] or [:b] changes\n     - call `f` with the values extracted from [:a] [:b]\n     - assoc the return value from `f` into the path  [:c]\n  "}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:path :group :db :fx-handler :re-frame.std-interceptors/not-found :debug :trim-v :db-handler :event :after :id :effects :error :coeffects :re-frame-path/db-store :groupEnd :ctx-handler :enrich :before :log}, :order [:id :debug :before :log :event :after :db :re-frame.std-interceptors/not-found :group :groupEnd :trim-v :db-handler :coeffects :fx-handler :effects :ctx-handler :re-frame-path/db-store :error :path :enrich]}, :doc "contains re-frame supplied, standard interceptors"}