/*
 *    Copyright (c) Dilvan A. Moreira 2015. All rights reserved.
 *    This file is part of ePad.
 *
 *     ePad is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License.
 *
 *     ePad is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with ePad.  If not, see <http://www.gnu.org/licenses/>.
 */
var br;
(function (br) {
    var usp;
    (function (usp) {
        var dilvanLab;
        (function (dilvanLab) {
            var roi3DEditor;
            (function (roi3DEditor) {
                var shaders;
                (function (shaders) {
                    shaders.axialFs = "\nprecision highp float;\nprecision highp sampler2D;\nprecision highp int;\n\nuniform int dso;\n\nuniform int imageInd;\nuniform int imagesPerAxis;\nuniform sampler2D uSampler;\nuniform sampler2D uDSO;\nuniform int greyCenter;\nuniform int greyWidth;\nuniform int shifting;\nuniform int rescaleSlope;\nuniform int rescaleIntercept;\n\n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\n\nvec4 getTexture(int ind, vec2 p) {\n    float ipa = float(imagesPerAxis);\n\tfloat x = (p.x + mod(float(ind), ipa))  / ipa;\n    float y = (p.y + float(3 - ind/imagesPerAxis)) / ipa;\n\n \tvec4 pix= texture2D(uSampler, vec2(x,y));\n    // For png file\n    float a = float(rescaleIntercept - rescaleSlope*shifting - greyCenter + greyWidth/2);\n    float grey = (float(rescaleSlope) * (pix.r*256.0 + pix.g)*255.0 + a)/float(greyWidth);\n\n    return vec4(grey, grey, grey, pix.a);\n}\n\nvec4 getDSU(int ind, vec2 p){\n    float ipa = float(imagesPerAxis);\n\tfloat x = (p.x + mod(float(ind), ipa))  / ipa;\n    float y = (p.y + float(3 - ind/imagesPerAxis)) / ipa;\n\n    vec4 bytes;\n    if (x<0.0 || x>1.0 || y<0.0 || y>1.0) return vec4(1.0,1.0,1.0,1.0);\n    return texture2D(uDSO, vec2(x,y));\n}\n\n// Axial Plane\nvoid main(void) {\n    if (dso==1) {\n        //PixArray bits;\n        gl_FragColor = getDSU(imageInd, v_texCoord);\n    } else\n        gl_FragColor = getTexture(imageInd, v_texCoord);\n}\n    ";
                    shaders.frontalFs = "\nprecision highp float;\nprecision highp sampler2D;\nprecision highp int;\n\nuniform int dso;\n\nuniform int imagesPerTexture;\nuniform int imagesPerAxis;\nuniform sampler2D uSampler;\nuniform sampler2D uDSO;\nuniform float yCoord;\nuniform int greyCenter;\nuniform int greyWidth;\nuniform int shifting;\nuniform int rescaleSlope;\nuniform int rescaleIntercept;\n\n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\n\nstruct PixArray {\n\tbool r[8];\n\tbool g[8];\n\tbool b[8];\n\tbool a[8];\n};\n\nvoid toByte(float num, out bool bits[8]){\n    int j;\n    int byte= int(num*255.0);\n    for (int i = 0; i < 8; i++) {\n        j = byte / 2;\n        bits[i] = (byte - j * 2)==1;\n        byte = j;\n    }\n}\n\nfloat fromByte(bool bits[8]){\n    float x= 0.0;\n    float df = 1.0/255.0; //int byte= int(num*255.0);\n    for (int i = 0; i < 8; i++) {\n        x = x + (bits[i]?df:0.0);\n        df = df *2.0;\n    }\n    return x;\n}\n\nvec4 getTexture(int ind, vec2 p) {\n    float ipa = float(imagesPerAxis);\n    float x = (p.x + mod(float(ind), ipa))  / ipa;\n    float y = (p.y + float(3 - ind/imagesPerAxis)) / ipa;\n\n\tvec4 pix= texture2D(uSampler, vec2(x,y));\n    // For png file\n    float a = float(rescaleIntercept - rescaleSlope*shifting - greyCenter + greyWidth/2);\n    float grey = (float(rescaleSlope) * (pix.r*256.0 + pix.g)*255.0 + a)/float(greyWidth);\n\n    return vec4(grey, grey, grey, pix.a);\n}\n\nvoid getTexture2(int ind, vec2 p, out PixArray pix){\n    float ipa = float(imagesPerAxis);\n    float x = (p.x + mod(float(ind), ipa))  / ipa;\n    float y = (p.y + float(3 - ind/imagesPerAxis)) / ipa;\n\n    vec4 bytes;\n    if (x<0.0 || x>1.0 || y<0.0 || y>1.0) bytes = vec4(1.0,1.0,1.0,1.0);\n    else bytes= texture2D(uDSO, vec2(x,y));\n\n    toByte(bytes.r, pix.r);\n    toByte(bytes.g, pix.g);\n    toByte(bytes.b, pix.b);\n    toByte(bytes.a, pix.a);\n}\n\n// Frontal Plane\nvoid main(void) {\n    float y= yCoord;\n\n    int i= int(   floor((1.0-v_texCoord.y)*float(imagesPerTexture-1)) );\n    float delta = fract((1.0-v_texCoord.y)*float(imagesPerTexture-1));  //y = y0 + (x - x0) (y1-y0)/(x1-x0)\n\n    if (i==(imagesPerTexture-1)) {i--; delta=1.0;}\n\n    if (dso==1) {\n       PixArray bits1;\n       PixArray bits2;\n       PixArray bits;\n\n       getTexture2(i,   vec2(v_texCoord.x, y), bits1);\n       getTexture2(i+1, vec2(v_texCoord.x, y), bits2);\n\n        for (int j=0; j<8; j++) {\n            bits.r[j] = (mix((bits1.r[j]?1.0:0.0), (bits2.r[j]?1.0:0.0), delta) > 0.5);\n            bits.g[j] = (mix((bits1.g[j]?1.0:0.0), (bits2.g[j]?1.0:0.0), delta) > 0.5);\n            bits.b[j] = (mix((bits1.b[j]?1.0:0.0), (bits2.b[j]?1.0:0.0), delta) > 0.5);\n            bits.a[j] = (mix((bits1.a[j]?1.0:0.0), (bits2.a[j]?1.0:0.0), delta) > 0.5);\n        }\n\n        if (bits.r[0])\n            gl_FragColor = vec4(1.0,1.0,1.0,1.0);\n        else\n            gl_FragColor = vec4(0.0,0.0,0.0,1.0);\n          /*\n           gl_FragColor = vec4(\n              fromByte(bits.r),\n              fromByte(bits.g),\n              fromByte(bits.b),\n              fromByte(bits.a));\n          */\n    }\n    else\n        gl_FragColor = mix(\n            getTexture(i,   vec2(v_texCoord.x, y)),\n            getTexture(i+1, vec2(v_texCoord.x, y)),\n            delta);\n}\n\n   ";
                    shaders.jpegTransfFs = "\nprecision highp float;\nprecision highp sampler2D;\nprecision highp int;\n\nuniform sampler2D uSampler;\nuniform int rescaleSlope;\nuniform int rescaleIntercept;\nuniform int shifting;\nuniform int defaultWW;\nuniform int defaultWC;\n\n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\n\nvoid main(void) {\n\tvec4 pix = texture2D(uSampler, vec2(v_texCoord.x, v_texCoord.y));\n\n\t// For jpg file\n    float x1 = (pix.r*float(defaultWW) - float(rescaleIntercept - rescaleSlope*shifting - defaultWC + defaultWW/2))/float(rescaleSlope);\n\tint x = int(floor(x1));\n    gl_FragColor = vec4(float(x/256) / 255.0, float(x - (x/256 * 256))/255.0, 0.0, pix.a);\n}\n    ";
                    shaders.moveFs = "\nprecision highp float;\nprecision highp sampler2D;\nprecision highp int;\n\nuniform sampler2D uDSO;\n\nuniform float sphereX; //X coordinate of the sphere center (max 1.0)\nuniform float sphereY; //Y coordinate of the sphere center (max 1.0)\nuniform float sphereRadius; //in units\n\nuniform float dy;\n\n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\n\nfloat square(float x) {return x*x;}\n\nbool isInsideCircle(vec2 pt) {\n    return (square(pt.x - sphereX) + square((pt.y - sphereY)*dy) <= square(sphereRadius));\n}\n\nvoid main(void) {\n\n    vec4 masks= texture2D(uDSO, v_texCoord);\n\n    if (!isInsideCircle(v_texCoord)) {\n        gl_FragColor = masks;\n        return;\n    }\n\n    vec4 ret = vec4(0.0);\n    vec4 k;\n    float power = 1.0;\n\n    for (int i=0; i<8; i++) {\n        k = mod(masks, 2.0); masks= floor(masks/2.0);\n        //if (i==bit) {\n            k.r = 1.0;\n        //}\n        ret += k*power;\n        power *= 2.0;\n    }\n    gl_FragColor = ret;\n}\n    ";
                    shaders.sagittalFs = "\nprecision highp float;\nprecision highp sampler2D;\nprecision highp int;\n\nuniform int dso;\n\nuniform int imagesPerTexture;\nuniform int imagesPerAxis;\nuniform sampler2D uSampler;\nuniform sampler2D uDSO;\nuniform float yCoord;\nuniform int greyCenter;\nuniform int greyWidth;\nuniform int shifting;\nuniform int rescaleSlope;\nuniform int rescaleIntercept;\n\n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\n\nvec4 getTexture(int ind, vec2 p) {\n    float ipa = float(imagesPerAxis);\n    float x = (p.x + mod(float(ind), ipa))  / ipa;\n    float y = (p.y + float(3 - ind/imagesPerAxis)) / ipa;\n\n \tvec4 pix= texture2D(uSampler, vec2(x,y));\n    // For png file\n    float a = float(rescaleIntercept - rescaleSlope*shifting - greyCenter + greyWidth/2);\n    float grey = (float(rescaleSlope) * (pix.r*256.0 + pix.g)*255.0 + a)/float(greyWidth);\n\n    return vec4(grey, grey, grey, pix.a);\n}\n\nvec4 getDso(int ind, float px, float py){\n    float ipa = float(imagesPerAxis);\n    float x = (px + mod(float(ind), ipa))  / ipa;\n    float y = (py + float(3 - ind/imagesPerAxis)) / ipa;\n\n    if (x<0.0 || x>1.0 || y<0.0 || y>1.0) return vec4(1.0,1.0,1.0,1.0);\n    return texture2D(uDSO, vec2(x,y));\n}\n\n// Sagittal Plane\nvoid main(void) {\n    float x= yCoord;\n\n\tint i= int(   floor((1.0-v_texCoord.y)*float(imagesPerTexture-1)) );\n    float delta = fract((1.0-v_texCoord.y)*float(imagesPerTexture-1));  //y = y0 + (x - x0) (y1-y0)/(x1-x0)\n\n    if (i==(imagesPerTexture-1)) {i--; delta=1.0;}\n\n    if (dso==1) {\n        vec4 pix1 = getDso(i,   x, (1.0 - v_texCoord.x));\n        vec4 pix2 = getDso(i+1, x, (1.0 - v_texCoord.x));\n\n        vec4 ret = vec4(0.0);\n        vec4 k, k1, k2;\n        float power = 1.0;\n\n        for (int i=0; i<8; i++) {\n            k1 = mod(pix1, 2.0); pix1= floor(pix1/2.0);\n            k2 = mod(pix2, 2.0); pix2= floor(pix2/2.0);\n            k = floor(mix(k1, k2, delta)*(2.0-exp2(-8.0)));      // 2^-8 smallest float in lowp precision\n            ret += k*power;\n            power *= 2.0;\n        }\n        gl_FragColor = ret;\n    } else\n        gl_FragColor = mix(\n            getTexture(i,   vec2(x, (1.0 - v_texCoord.x))),\n            getTexture(i+1, vec2(x, (1.0 - v_texCoord.x))),\n            delta);\n}\n    ";
                    shaders.simpleFs = "\nprecision highp float;\nprecision highp sampler2D;\nprecision highp int;\n\nuniform sampler2D uSampler;\nuniform sampler2D uDSO;\n\n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\nuniform float sphereX; //X coordinate of the sphere center (max 1.0)\nuniform float sphereY; //Y coordinate of the sphere center (max 1.0)\n//uniform float sphereZ; //Z coordinate of the sphere center, proportional to X and Y\nuniform float sphereRadius; //in units\nuniform float zoom;\nuniform float alpha;\nuniform float beta;\nuniform float lineX;\nuniform float lineY;\n\nfloat square(float x) {return x*x;}\n\nbool isLine(float x, float y) {\n    float d= 0.1/zoom;\n    if (x>lineX-d && x<lineX+d && y>lineY-d && y<lineY+d) return false;\n    d= 0.002/zoom;\n    if (x>(lineX-d) && x<(lineX+d) || y>(lineY-d) && y<(lineY+d)) return true;\n    return false;\n}\n\nbool isCircle(vec2 pt) {\n    float r = square(pt.x - sphereX) + square(pt.y - sphereY);\n    return (r >= square(sphereRadius*alpha-0.002) && r <= square(sphereRadius*alpha+0.002));\n}\n\n// Return mask with border detection\nvec4 findBorder(float x, float y, vec4 p) {\n    //    d\n    //  a p b\n    //    c\n\n    // vec4 p = floor(texture2D(uDSO, vec2(x,   y   )) *255.0);\n    //TODO: Change the 512 for something that changes with the resolution\n    float dt = 1.0/512.0;\n    vec4 a = floor(texture2D(uDSO, vec2(x-dt,y   )) *255.0);\n    vec4 b = floor(texture2D(uDSO, vec2(x+dt,y   )) *255.0);\n    vec4 c = floor(texture2D(uDSO, vec2(x,   y-dt)) *255.0);\n    vec4 d = floor(texture2D(uDSO, vec2(x,   y+dt)) *255.0);\n    vec4 k, ka, kb, kc, kd;\n\n    float power= 1.0;\n    vec4 mask = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = 0; i < 8; i++) {\n        k  = mod(p, 2.0); p= floor(p/2.0);\n        if (k==vec4(0.0,0.0,0.0,0.0)) continue;\n        ka = mod(a, 2.0); a= floor(a/2.0);\n        kb = mod(b, 2.0); b= floor(b/2.0);\n        kc = mod(c, 2.0); c= floor(c/2.0);\n        kd = mod(d, 2.0); d= floor(d/2.0);\n\n        mask += (k*mod(ka*kb*kc*kd + 1.0, 2.0))*power;\n        power *= 2.0;\n    }\n    return mask;\n}\n\nvec4 getTexture(vec2 p) {\n\n    vec4 mask = floor(texture2D(uDSO, vec2(p.x, p.y)) *255.0);\n    mask = findBorder(p.x, p.y, mask);\n\n\tvec4 pix= texture2D(uSampler, p);\n    float grey = pix.r;\n\n    float red = 0.0;\n    if (mod(mask, 2.0).r==1.0) {red = 1.0; grey = grey *0.3;}\n    else red = grey;\n\n    return vec4(red, grey, grey, 1.0);//pix.a);\n}\n\nvoid main(void) {\n\t//\tCorrect compression in x axis (for sagittal and frontal\n    vec2 pt = vec2(v_texCoord.x/alpha+beta, v_texCoord.y);\n\n    // If it's outside the view\n    if (pt.x<0.0 || pt.x>1.0 || pt.y<0.0 || pt.y>1.0) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\n    // Test if it's inside the circle\n    if (isLine(pt.x, pt.y))//v_texCoord.x, v_texCoord.y))\n        gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); // green color\n    // Test if it's inside the circle\n    else if (isCircle(v_texCoord))\n        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0); // blue color\n    else\n\t\tgl_FragColor = getTexture(pt);\n}\n\n    ";
                    shaders.simpleVs = "\nprecision highp float;\nprecision highp sampler2D;\nprecision highp int;\n\nattribute vec2 a_texCoord;\nattribute vec2 a_position;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n\tgl_Position = vec4(a_position, 0, 1);\n\t// pass the texCoord to the fragment shader\n   \t// The GPU will interpolate this value between points\n   \tv_texCoord = a_texCoord;\n}\n    ";
                    shaders.stampFs = "\nprecision highp float;\nprecision highp sampler2D;\nprecision highp int;\n\nuniform int imagesPerAxis;\nuniform sampler2D uDSO;\nuniform sampler2D spheres;\n\nuniform int baseInd;   //True index of the first image in this set\nuniform float dz;      //Distance between slices, in units\nuniform int cmdSize;\n//uniform float sphereX;\n//uniform float sphereY;\n//uniform float sphereZ;\n//vec3 sphe = vec3(sphereX, sphereY, sphereZ);\n\nuniform float maxX;\nconst int maxSize = 30000;\n//uniform vec4 spheres1[maxSize];\nuniform float sphereRadius; //in units\n\n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\n\nfloat square(float x) {return x*x;}\n\nvec4 getSphere(int i) {\n    float j = float(i);\n    return texture2D(spheres, vec2(mod(j,maxX)/maxX, 1.0 - floor(j/maxX)/maxX));\n}\n\n//   It took 5 seconds (4s with cube test) in the one line test (one line from\n//   the top to the botton with default cursor radius)\nbool isInsideSphere(vec3 plane) {\n    vec3 delta;\n    for(int i=0; i<maxSize; i++) {\n        if (i>=cmdSize) break;\n\n        //delta = plane-spheres1[i].xyz;\n        delta = plane-getSphere(i).xyz;\n\n        // Test first the cube where the sphere is\n        if (delta.x>sphereRadius || delta.y>sphereRadius) continue;\n\n        if (square(delta.x) + square(delta.y) <= square(sphereRadius) - square(delta.z))\n            return true;\n    }\n    return false;\n}\n\n//   Disposition of images in the 4x4 grid\n/*   0  1  2  3\n     4  5  6  7\n     8  9 10 11\n    12 13 14 15\n*/\nvoid main(void) {\n    vec2 p = v_texCoord;\n\n    // Calculate image index from point p\n    float ipa = float(imagesPerAxis);\n    float indX = ceil(p.x*ipa)-1.0;\n    if (indX<0.0) indX = 0.0;\n    float indY = ceil(p.y*ipa)-1.0;\n    if (indY<0.0) indY = 0.0;\n        float ind = (3.0-indY) * ipa + indX;\n\n    vec4 masks = texture2D(uDSO, p);\n\tvec2 p2 = vec2(fract(p.x*ipa), fract(p.y*ipa));\n\n    bool isInside = isInsideSphere(vec3(p2, (ind + float(baseInd)) * dz));\n\n    vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 k;\n\n    masks= floor(masks*255.0);\n    int bit = 0;\n    float power = 1.0;\n\n    for (int i = 0; i < 8; i++) {\n        k = mod(masks, 2.0); masks= floor(masks/2.0);\n        //if (i==bit) {\n            k.r = (isInside?1.0:k.r);\n        //}\n        ret += k*power;\n        power *= 2.0;\n    }\n    gl_FragColor = ret/255.0;\n}\n    ";
                    shaders.transfVs = "\nprecision highp float;\nprecision highp sampler2D;\nprecision highp int;\n\nattribute vec2 a_texCoord;\nattribute vec2 a_position;\n\nuniform vec2 u_translation;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n\tgl_Position = vec4(a_position + u_translation, 0, 1);\n\t// pass the texCoord to the fragment shader\n   \t// The GPU will interpolate this value between points\n   \tv_texCoord = a_texCoord;\n}\n    ";
                })(shaders = roi3DEditor.shaders || (roi3DEditor.shaders = {}));
            })(roi3DEditor = dilvanLab.roi3DEditor || (dilvanLab.roi3DEditor = {}));
        })(dilvanLab = usp.dilvanLab || (usp.dilvanLab = {}));
    })(usp = br.usp || (br.usp = {}));
})(br || (br = {}));
